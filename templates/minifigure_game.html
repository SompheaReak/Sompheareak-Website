<!-- This template contains the self-contained game logic -->
<script src="https://cdn.tailwindcss.com"></script> 

<!-- Firebase SDK Imports (Mandatory for Firestore and Auth) -->
<script type="module">
    import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
    import { getAuth, signInWithCustomToken, signInAnonymously, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
    import { getFirestore, doc, getDoc, updateDoc, onSnapshot, setDoc, runTransaction } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

    // Global variables provided by the Canvas environment
    const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
    const firebaseConfig = typeof __firebase_config !== 'undefined' ? JSON.parse(__firebase_config) : {};
    const initialAuthToken = typeof __initial_auth_token !== 'undefined' ? __initial_auth_token : null;

    // Global Firebase instances
    window.db = null;
    window.auth = null;
    window.currentUserId = null;
    window.gameInitializationComplete = false;
    
    // Paths
    window.getDrawCountPath = (uid) => `artifacts/${appId}/users/${uid}/drawCounts/main`;
    window.getCodeDoc = (code) => doc(db, `artifacts/${appId}/public/codes/${code}`);

    async function initializeFirebase() {
        if (!firebaseConfig || Object.keys(firebaseConfig).length === 0) {
            console.error("Firebase config is missing.");
            return;
        }

        const app = initializeApp(firebaseConfig);
        window.db = getFirestore(app);
        window.auth = getAuth(app);
        
        // 1. Authenticate User
        try {
            if (initialAuthToken) {
                await signInWithCustomToken(auth, initialAuthToken);
            } else {
                await signInAnonymously(auth);
            }
        } catch (error) {
            console.error("Firebase authentication failed:", error);
            await signInAnonymously(auth); // Fallback to anonymous sign-in
        }
        
        // 2. Set up Auth Listener and complete game initialization
        onAuthStateChanged(auth, (user) => {
            if (user) {
                window.currentUserId = user.uid;
                // Only proceed to run the game logic once we have a user ID
                if (!window.gameInitializationComplete) {
                    window.initGame();
                    window.gameInitializationComplete = true;
                }
            } else {
                console.warn("User is not signed in.");
            }
        });
    }

    initializeFirebase();
</script>

<style>
    :root {
        --lego-yellow: #FFC300;
        --lego-red: #C80815;
        --dark-blue: #1A202C;
    }
    
    body {
        font-family: 'Inter', sans-serif;
    }

    /* Keyframes for the shaking/loading animation */
    @keyframes shake {
        0% { transform: translate(1px, 1px) rotate(0deg); }
        10% { transform: translate(-1px, -2px) rotate(-1deg); }
        20% { transform: translate(-3px, 0px) rotate(1deg); }
        30% { transform: translate(3px, 2px) rotate(0deg); }
        40% { transform: translate(1px, -1px) rotate(1deg); }
        50% { transform: translate(-1px, 2px) rotate(-1deg); }
        60% { transform: translate(-3px, 1px) rotate(0deg); }
        70% { transform: translate(3px, 1px) rotate(-1deg); }
        80% { transform: translate(-1px, -1px) rotate(1deg); }
        90% { transform: translate(1px, 2px) rotate(0deg); }
        100% { transform: translate(1px, -2px) rotate(-1deg); }
    }

    .loading-animation {
        animation: shake 0.2s infinite;
        background-color: var(--lego-yellow);
    }

    .reveal-card {
        transition: transform 0.5s ease-out, opacity 0.5s ease-out;
    }
    .reveal-card:not(.revealed) {
        transform: scale(0.8) translateY(20px);
        opacity: 0;
    }
    .reveal-card.revealed {
        transform: scale(1) translateY(0);
        opacity: 1;
    }
    
    /* Custom style for the rarity badge background */
    .rarity-common { background-color: #3b82f6; } /* Blue */
    .rarity-rare { background-color: #f59e0b; } /* Amber */
    .rarity-super-rare { background-color: #ef4444; } /* Red */
    .rarity-ultra-rare { background-color: #a855f7; } /* Purple */
</style>

<!-- Main Game Container -->
<div class="p-4 md:p-8 min-h-screen bg-gray-900 flex flex-col items-center">
    <!-- Back Button -->
    <a href="/" class="self-start text-yellow-500 hover:text-yellow-400 mb-4 flex items-center transition duration-150">
        <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="2.5" stroke="currentColor" class="w-5 h-5 mr-1">
          <path stroke-linecap="round" stroke-linejoin="round" d="M10.5 19.5 3 12m0 0 7.5-7.5M3 12h18" />
        </svg>
        Back to Home
    </a>
    
    <div id="minifigure-app" class="w-full max-w-sm bg-gray-800 border-4 border-yellow-500 shadow-2xl p-6 rounded-xl">
        
        <!-- Header -->
        <h1 class="text-3xl font-black text-yellow-500 text-center mb-4 uppercase tracking-wider">
            Mystery Blind Box
        </h1>

        <!-- Draw Count Info -->
        <div class="flex justify-between items-center mb-6 p-3 rounded-lg bg-gray-700 shadow-inner">
            <span class="text-lg font-semibold text-gray-300">Draws Available:</span>
            <span id="draw-count" class="text-3xl font-extrabold text-red-500">...</span>
        </div>

        <!-- Result Area (dynamically filled by JS) -->
        <div id="result-area" class="mt-4 min-h-[250px] flex items-center justify-center">
            <div class="text-center p-4 text-gray-400">
                <p class="mb-2 text-lg font-semibold">Ready to test your luck?</p>
                <p class="text-sm">Press the button below to open a brand new blind box!</p>
            </div>
        </div>

        <!-- Draw Button -->
        <button id="draw-button" class="w-full py-4 text-xl font-bold bg-gray-500 text-white rounded-xl shadow-lg uppercase mt-6" disabled>
            Loading...
        </button>

        <hr class="border-gray-700 my-6">

        <!-- Code Redemption Area -->
        <h2 class="text-xl font-bold text-yellow-500 mb-3">Redeem Draw Code</h2>
        <div class="flex flex-col space-y-3">
            <input type="text" id="code-input" placeholder="Enter your secret code..." class="p-3 rounded-lg bg-gray-700 text-white border border-gray-600 focus:border-yellow-500 focus:outline-none placeholder-gray-400">
            <button id="redeem-button" class="w-full py-3 text-sm font-semibold bg-green-600 hover:bg-green-700 text-white rounded-xl shadow transition duration-200">
                Verify & Redeem
            </button>
            <p id="redeem-message" class="text-center text-sm min-h-6"></p>
        </div>
        
    </div>
    
    <!-- Minifigure List Display (for reference) -->
    <div class="w-full max-w-sm mt-8 p-4 bg-gray-800 rounded-xl border border-gray-700">
        <h2 class="text-xl font-bold text-yellow-500 mb-3 border-b border-yellow-500 pb-2">Available Minifigures <span id="fig-count-title"></span></h2>
        <!-- üí• 5-COLUMN GRID CONTAINER üí• -->
        <div id="minifigure-list" class="grid grid-cols-5 gap-2">
            <!-- Images will be populated by JS -->
        </div>
    </div>
    
    <!-- Display User ID for debugging/sharing -->
    <p class="text-xs text-gray-500 mt-4">User ID: <span id="user-id-display">N/A (Loading...)</span></p>
</div>

<!-- Game Logic -->
<script>
    // --- üí• ADD YOUR MINIFIGURES HERE üí• ---
    // Format: name:"Name", rarity:"Rarity", color:"tailwind-color-code", image_url:"static/images/filename.jpg"
    // Rarity options for weighting: "Common", "Rare", "Super Rare", "Ultra Rare"
    const FIGURE_STRINGS = [
        'name:"Kai", rarity:"Rare", color:"red-600", image_url:"static/images/01.jpg"',
        'name:"Classic Astronaut", rarity:"Common", color:"blue-500", image_url:"static/images/astronaut.png"',
        'name:"Pirate Captain Redbeard", rarity:"Rare", color:"red-600", image_url:"static/images/pirate.png"',
        'name:"Forest Elf Warrior", rarity:"Common", color:"green-500", image_url:"static/images/elf.png"',
        'name:"Dinosaur Suit Guy", rarity:"Super Rare", color:"lime-500", image_url:"static/images/dino.png"',
        'name:"Unicorn Girl", rarity:"Ultra Rare", color:"pink-500", image_url:"static/images/unicorn.png"',
        'name:"Hot Dog Vendor", rarity:"Common", color:"orange-500", image_url:"static/images/hotdog.png"',
        'name:"Interstellar Robot", rarity:"Super Rare", color:"gray-300", image_url:"static/images/robot.png"',
        'name:"Mummy Pharaoh", rarity:"Rare", color:"yellow-200", image_url:"static/images/mummy.png"',
    ];
    // ----------------------------------------
    
    // Global state
    let MINIFIGURES = [];
    let currentDraws = 0;
    let isLoading = false;
    let unsubscribeDraws = null; // To hold the Firestore snapshot listener

    // UI Elements
    const drawCountElement = document.getElementById('draw-count');
    const drawButton = document.getElementById('draw-button');
    const resultArea = document.getElementById('result-area');
    const redeemButton = document.getElementById('redeem-button');
    const codeInput = document.getElementById('code-input');
    const redeemMessage = document.getElementById('redeem-message');
    const userIdDisplay = document.getElementById('user-id-display');

    // --- Utility Functions ---
    function parseFigureString(str) {
        const figure = {};
        const regex = /(\w+):"([^"]+)"/g;
        let match;
        while ((match = regex.exec(str)) !== null) {
            figure[match[1]] = match[2];
        }
        return figure;
    }
    
    function initializeMinifigures() {
        MINIFIGURES = FIGURE_STRINGS.map(parseFigureString);
        
        const listElement = document.getElementById('minifigure-list');
        const figCountTitle = document.getElementById('fig-count-title');
        
        if (figCountTitle) {
            figCountTitle.textContent = `(${MINIFIGURES.length})`;
        }

        if (listElement) {
             listElement.innerHTML = MINIFIGURES.map(fig => 
                `
                <div class="relative group w-full flex flex-col items-center justify-center p-0.5 bg-gray-700 rounded-lg overflow-hidden transition duration-150 hover:bg-yellow-600 cursor-help">
                    <img src="/${fig.image_url}" 
                         alt="${fig.name}" 
                         class="w-full h-auto object-contain p-0.5" 
                         title="${fig.name} (${fig.rarity})" 
                         onerror="this.onerror=null; this.src='https://placehold.co/40x40/4A5568/FFFFFF?text=?'"/>
                    
                    <!-- Name/Rarity Tooltip on hover -->
                    <span class="absolute bottom-0 left-0 right-0 bg-gray-900 bg-opacity-90 text-white text-[9px] font-semibold text-center py-0.5 opacity-0 group-hover:opacity-100 transition-opacity duration-300 pointer-events-none">
                        ${fig.name}
                    </span>
                </div>
                `
             ).join('');
        }
    }
    
    function drawMinifigure() {
        const weightedList = [];
        MINIFIGURES.forEach(fig => {
            let weight = 0;
            // Rarity weighting
            if (fig.rarity === "Common") weight = 40;
            else if (fig.rarity === "Rare") weight = 25;
            else if (fig.rarity === "Super Rare") weight = 10;
            else if (fig.rarity === "Ultra Rare") weight = 5;
            
            for (let i = 0; i < weight; i++) {
                weightedList.push(fig);
            }
        });

        if (weightedList.length === 0) {
            console.error("No figures available for draw.");
            return null;
        }

        const randomIndex = Math.floor(Math.random() * weightedList.length);
        return weightedList[randomIndex];
    }
    
    // --- Firestore Draw Count Management ---

    function listenForDrawCount() {
        if (unsubscribeDraws) unsubscribeDraws();
        
        const drawCountRef = doc(db, getDrawCountPath(currentUserId));
        
        // Listen for real-time changes
        unsubscribeDraws = onSnapshot(drawCountRef, (docSnap) => {
            if (docSnap.exists()) {
                currentDraws = docSnap.data().count || 0;
            } else {
                // Initialize if document doesn't exist
                currentDraws = 0;
                setDoc(drawCountRef, { count: 0 }).catch(console.error);
            }
            updateDrawCountUI();
        }, (error) => {
            console.error("Error listening to draw count:", error);
            updateDrawCountUI(); // Show current local count on error
        });
    }

    async function decrementDrawCount() {
        const drawCountRef = doc(db, getDrawCountPath(currentUserId));
        
        try {
            await runTransaction(db, async (transaction) => {
                const docSnap = await transaction.get(drawCountRef);
                if (!docSnap.exists()) {
                    throw "Draw count document does not exist!";
                }
                const newCount = (docSnap.data().count || 0) - 1;
                if (newCount < 0) {
                    throw "Not enough draws.";
                }
                transaction.update(drawCountRef, { count: newCount });
            });
            return true;
        } catch (e) {
            console.error("Transaction failed:", e);
            return false;
        }
    }
    
    async function increaseDrawCount(amount) {
        const drawCountRef = doc(db, getDrawCountPath(currentUserId));
        
        try {
            await runTransaction(db, async (transaction) => {
                const docSnap = await transaction.get(drawCountRef);
                const currentCount = docSnap.exists() ? (docSnap.data().count || 0) : 0;
                const newCount = currentCount + amount;
                
                transaction.set(drawCountRef, { count: newCount }, { merge: true });
            });
            return true;
        } catch (e) {
            console.error("Failed to increase draw count:", e);
            return false;
        }
    }

    // --- UI Update ---

    function updateDrawCountUI() {
        if (drawCountElement) {
            drawCountElement.textContent = currentDraws;
        }
        
        if (drawButton) {
            if (currentDraws <= 0) {
                drawButton.disabled = true;
                drawButton.textContent = 'No Draws Left!';
                drawButton.classList.remove('bg-red-600', 'hover:bg-red-700');
                drawButton.classList.add('bg-gray-500', 'cursor-not-allowed');
            } else {
                drawButton.disabled = false;
                drawButton.textContent = 'Open Blind Box (1 Draw)';
                drawButton.classList.remove('bg-gray-500', 'cursor-not-allowed');
                drawButton.classList.add('bg-red-600', 'hover:bg-red-700');
            }
        }
    }

    function resetButtonState() {
        // Since we are using an onSnapshot listener, the UI update is automatic
        // after the transaction commits, so we only need to reset the loading state.
        isLoading = false;
    }
    
    // --- Code Redemption Logic ---

    async function handleRedeemCode() {
        if (!currentUserId || isLoading) return;
        
        const code = codeInput.value.trim().toUpperCase();
        if (code.length === 0) {
            displayRedeemMessage('Please enter a code.', 'text-yellow-400');
            return;
        }
        
        isLoading = true;
        redeemButton.disabled = true;
        redeemButton.textContent = 'Verifying...';
        displayRedeemMessage('');

        try {
            const codeRef = getCodeDoc(code);
            const codeSnap = await getDoc(codeRef);

            if (!codeSnap.exists()) {
                displayRedeemMessage('Invalid code. Please check your entry.', 'text-red-400');
                return;
            }

            const codeData = codeSnap.data();

            if (codeData.redeemed) {
                displayRedeemMessage('Code already used.', 'text-red-400');
                return;
            }
            
            const drawsToAdd = codeData.count || 5; // Default to 5 if count is missing

            // 1. Mark the code as redeemed (Critical atomic step)
            await updateDoc(codeRef, { redeemed: true, redeemedBy: currentUserId, redeemedAt: new Date().toISOString() });
            
            // 2. Increase the user's draw count
            const success = await increaseDrawCount(drawsToAdd);

            if (success) {
                displayRedeemMessage(`Success! Added ${drawsToAdd} draws to your account.`, 'text-green-400');
                codeInput.value = '';
            } else {
                // If draw count update failed, try to revert the redeemed status (best effort)
                await updateDoc(codeRef, { redeemed: false, redeemedBy: null, redeemedAt: null });
                displayRedeemMessage('Verification failed. Please try again.', 'text-red-400');
            }

        } catch (error) {
            console.error("Redemption error:", error);
            displayRedeemMessage('An error occurred during verification.', 'text-red-400');
        } finally {
            isLoading = false;
            redeemButton.disabled = false;
            redeemButton.textContent = 'Verify & Redeem';
        }
    }

    function displayRedeemMessage(message, colorClass) {
        redeemMessage.textContent = message;
        redeemMessage.className = `text-center text-sm min-h-6 ${colorClass}`;
    }

    // --- Main Draw Logic ---
    async function handleDrawClick() {
        if (isLoading || currentDraws <= 0) return;
        
        // 1. Try to decrement count via transaction (secure)
        const decrementSuccess = await decrementDrawCount();
        if (!decrementSuccess) {
            displayRedeemMessage('Draw failed. You might have 0 draws left.', 'text-red-400');
            return;
        }
        
        // Count successfully decremented in Firestore, proceed with animation
        let isLoading = true;
        drawButton.disabled = true;
        drawButton.textContent = 'Testing Luck...';
        drawButton.classList.remove('bg-red-600', 'hover:bg-red-700');
        drawButton.classList.add('bg-gray-500', 'cursor-not-allowed');

        // Start Loading Animation
        resultArea.innerHTML = `
            <div id="mystery-box" class="loading-animation w-32 h-32 rounded-lg flex items-center justify-center shadow-inner">
                <span class="text-6xl" role="img" aria-label="Mystery Box">‚ùì</span>
            </div>
        `;

        // Wait for suspense (3 seconds)
        setTimeout(() => {
            const figure = drawMinifigure();
            if (!figure) {
                resultArea.innerHTML = `<p class="text-red-400">Error: Could not draw a figure.</p>`;
                resetButtonState();
                return;
            }

            const borderColorClass = figure.color ? `border-${figure.color}` : 'border-yellow-500';
            const rarityClass = `rarity-${figure.rarity.toLowerCase().replace(' ', '-')}`;

            // Reveal result
            resultArea.innerHTML = `
                <div id="reveal-card" class="reveal-card flex flex-col items-center p-6 bg-gray-800 rounded-xl shadow-2xl w-full max-w-xs border-b-8 ${borderColorClass}">
                    <div class="text-8xl mb-4 p-2 bg-gray-700 rounded-full shadow-lg border-2 border-yellow-500 overflow-hidden w-28 h-28 flex items-center justify-center">
                        <img src="/${figure.image_url}" alt="${figure.name}" class="w-full h-full object-contain" onerror="this.onerror=null; this.src='https://placehold.co/96x96/4A5568/FFFFFF?text=?'"/>
                    </div>
                    <h2 class="text-3xl font-extrabold text-white text-center mb-1">${figure.name}</h2>
                    <p class="text-sm font-semibold mb-3 text-gray-400">Series Collection</p>
                    <span class="px-4 py-1 text-xs font-bold rounded-full text-gray-900 shadow-md ${rarityClass}">
                        ${figure.rarity.toUpperCase()}
                    </span>
                </div>
            `;

            setTimeout(() => {
                document.getElementById('reveal-card')?.classList.add('revealed');
            }, 50);

            // Reset button state is handled by the onSnapshot listener from Firestore
            isLoading = false;
        }, 3000); 
    }
    
    // --- Initialization ---

    // Exposed globally for the module script to call after authentication
    window.initGame = function() {
        if (!window.db || !window.currentUserId) {
            console.error("Firebase not initialized or user ID missing.");
            return;
        }

        // Display user ID for debugging
        if (userIdDisplay) {
            userIdDisplay.textContent = window.currentUserId;
        }

        // Initialize Minifigures list (only needs to run once)
        initializeMinifigures();
        
        // Start listening to the user's draw count in real-time
        listenForDrawCount();
        
        // Event Listeners
        if (drawButton) {
            drawButton.addEventListener('click', handleDrawClick);
        }
        if (redeemButton) {
            redeemButton.addEventListener('click', handleRedeemCode);
        }
    };
</script>

